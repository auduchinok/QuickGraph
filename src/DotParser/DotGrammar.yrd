{
open DotParserProject.GraphData
open Option
open System.Collections.Generic
open System.Linq
open QuickGraph

let addEdge (d: GraphData * Node list) (n2: Node list) =
    let g, n1 = d
    g.AddEdge n1 n2
}

tokens {
    _ of string
}

options {
    translate = true
    module = "DotParserProject.Gen.DotParser"
    infEpsPath = epsilons
    pos = uint64
}

module DotGrammar

[<Start>]
graph: g=graph_type [ID] LBRACE r=stmt_list<<g>> RBRACE { r }

graph_type: s=[STRICT] d=(GRAPH { false } | DIGRAPH { true }) { GraphData (d, isSome s) }

stmt_list<<(g: GraphData)>>: [r=stmt<<g>> [SEMI] [stmt_list<<r>>] { }] { g }

stmt<<(g: GraphData)>>:
    node_stmt<<g>> { g }
  | edge_stmt<<g>> { g }
  | attr_stmt<<g>> { g }
  | subgraph<<g>>  { g }

attr_stmt<<(g: GraphData)>>:
    k=(GRAPH { "graph" } | NODE { "node" } | EDGE { "edge" }) a=attr_list { g.AddAttributes k a }

attr_list: LBRACK a=[a_list] RBRACK { if isSome a then a.Value else [] }

a_list: a=attr [SEMI { } | COMMA { }] l=[a_list] { if isSome l then a :: l.Value else [a] }
(* -SEMI | -COMMA doesn't work *)

attr: k=ID ASSIGN v=ID { (k, v) }

node_stmt<<(g: GraphData)>>: node_id<<g>> { }

edge_stmt<<(g: GraphData)>>: n=nodes<<g>> edge_rhs<<(g, n)>> { } 

edge_rhs<<(d: GraphData * Node list)>>:
    edgeop n=nodes<<(fst d)>> r=[edge_rhs<<(fst d, n)>>] { addEdge d n }

nodes<<(g: GraphData)>>: n=node_id<<g>> { n } | n=subgraph<<g>> { n }
(* why n= ... {n} needed ? *)

edgeop: EDGE { } | DIEDGE { }

node_id<<(g: GraphData)>>: name=ID { g.AddNode name }

subgraph<<(g: GraphData)>>:
    [SUBGRAPH [ID] { }] LBRACE r=stmt_list<<(GraphData(g))>> RBRACE { g.AddSubgraph(r) }